// Docker Ï†ïÎ¶¨ Ìï®Ïàò - ÏïàÏì∞Îäî Î¶¨ÏÜåÏä§Î•º ÌôïÏã§ÌïòÍ≤å Ï†úÍ±∞
def dockerAggressiveCleanup() {
    def dockerPath = findDockerExecutable()
    if (!dockerPath) {
        println "‚ùå Docker not found. Skipping cleanup."
        return
    }
    
    println "\nüîç Analyzing Docker resources for cleanup..."
    
    // 1. ÌòÑÏû¨ Ïã§Ìñâ Ï§ëÏù∏ Ïª®ÌÖåÏù¥ÎÑàÏùò Ïù¥ÎØ∏ÏßÄ ID ÏàòÏßë (Î≥¥Ìò∏ ÎåÄÏÉÅ)
    def runningImages = [] as Set
    try {
        def output = new ByteArrayOutputStream()
        project.exec {
            commandLine = [dockerPath, "ps", "--format", "{{.Image}}"]
            standardOutput = output
            ignoreExitValue = true
        }
        runningImages.addAll(output.toString().split("\n").findAll { it.trim() })
        println "üìå Protected images (currently in use): ${runningImages.size()}"
    } catch (Exception e) {
        println "‚ö†Ô∏è Could not get running containers: ${e.message}"
    }
    
    // 2. Ï§ëÎã®Îêú Ïª®ÌÖåÏù¥ÎÑà Î™®Îëê Ï†úÍ±∞
    println "üßπ Removing stopped containers..."
    executeDockerCommand("container", "prune", "-f")
    
    // 3. Dangling Ïù¥ÎØ∏ÏßÄ Ï†úÍ±∞ (ÌÉúÍ∑∏ ÏóÜÎäî Ïù¥ÎØ∏ÏßÄ)
    println "üßπ Removing dangling images..."
    executeDockerCommand("image", "prune", "-f")
    
    // 4. AsyncSite ÌîÑÎ°úÏ†ùÌä∏Ïùò ÎØ∏ÏÇ¨Ïö© Ïù¥ÎØ∏ÏßÄ Ï†úÍ±∞
    println "üßπ Removing unused AsyncSite images..."
    try {
        def output = new ByteArrayOutputStream()
        project.exec {
            commandLine = [dockerPath, "images", "--filter", "reference=asyncsite/*", "--format", "{{.Repository}}:{{.Tag}}"]
            standardOutput = output
            ignoreExitValue = true
        }
        
        // ghcr.io/asyncsite/* Ïù¥ÎØ∏ÏßÄÎèÑ Ï≤òÎ¶¨
        def output2 = new ByteArrayOutputStream()
        project.exec {
            commandLine = [dockerPath, "images", "--filter", "reference=ghcr.io/asyncsite/*", "--format", "{{.Repository}}:{{.Tag}}"]
            standardOutput = output2
            ignoreExitValue = true
        }
        
        def asyncImages = (output.toString().split("\n") + output2.toString().split("\n")).findAll { it.trim() }
        def removedCount = 0
        
        asyncImages.each { image ->
            if (!runningImages.contains(image) && !image.contains("<none>")) {
                println "  Removing: $image"
                if (executeDockerCommand("rmi", image, "-f")) {
                    removedCount++
                }
            }
        }
        println "  Removed $removedCount AsyncSite images"
    } catch (Exception e) {
        println "‚ö†Ô∏è Error removing AsyncSite images: ${e.message}"
    }
    
    // 5. ÎπåÎìú Ï∫êÏãú Ï†ïÎ¶¨ (24ÏãúÍ∞Ñ Ïù¥ÏÉÅ Îêú Í≤ÉÎßå)
    println "üßπ Cleaning old build cache (>24h)..."
    executeDockerCommand("builder", "prune", "-f", "--filter", "until=24h")
    
    // 6. ÎØ∏ÏÇ¨Ïö© ÎÑ§Ìä∏ÏõåÌÅ¨ Ï†úÍ±∞ (asyncsite-networkÎäî Ïú†ÏßÄ)
    println "üßπ Removing unused networks..."
    executeDockerCommand("network", "prune", "-f")
    
    // 7. ÎØ∏ÏÇ¨Ïö© Î≥ºÎ•® Ï†úÍ±∞ (ÏòµÏÖò - Í∏∞Î≥∏Ï†ÅÏúºÎ°ú ÎπÑÌôúÏÑ±Ìôî)
    def cleanVolumes = project.hasProperty("cleanDockerVolumes") && project.cleanDockerVolumes == "true"
    if (cleanVolumes) {
        println "‚ö†Ô∏è  WARNING: Removing unused volumes (data will be lost!)..."
        executeDockerCommand("volume", "prune", "-f")
    }
    
    // 8. ÏµúÏ¢Ö ÎîîÏä§ÌÅ¨ ÏÇ¨Ïö©Îüâ ÌôïÏù∏
    println "\nüìä Docker disk usage after cleanup:"
    def dfOutput = new ByteArrayOutputStream()
    try {
        project.exec {
            commandLine = [dockerPath, "system", "df"]
            standardOutput = dfOutput
            ignoreExitValue = true
        }
        println dfOutput.toString()
    } catch (Exception e) {
        println "Could not get disk usage: ${e.message}"
    }
    
    println "‚ú® Docker cleanup completed!\n"
}

// Docker Ïã§Ìñâ ÌååÏùº Ï∞æÍ∏∞
def findDockerExecutable() {
    def possiblePaths = [
        "/usr/local/bin/docker",
        "/usr/bin/docker",
        "/opt/homebrew/bin/docker",
        "/Applications/Docker.app/Contents/Resources/bin/docker"
    ]

    for (path in possiblePaths) {
        if (file(path).exists()) {
            return path
        }
    }

    // which Î™ÖÎ†πÏñ¥Î°ú docker Ï∞æÍ∏∞
    try {
        def process = "which docker".execute()
        def dockerPath = process.text.trim()
        if (dockerPath && file(dockerPath).exists()) {
            return dockerPath
        }
    } catch (Exception e) {
        // ignore
    }

    return null
}

// Docker Î™ÖÎ†πÏñ¥ Ïã§Ìñâ Ìó¨Ìçº Ìï®Ïàò
def executeDockerCommand(String... args) {
    def dockerPath = findDockerExecutable()
    if (!dockerPath) {
        println "‚ùå Docker not found. Please make sure Docker Desktop is installed and running."
        println "   You can also run Docker commands directly from terminal."
        return false
    }

    try {
        def output = new ByteArrayOutputStream()
        def errorOutput = new ByteArrayOutputStream()
        
        def result = project.exec {
            commandLine = [dockerPath] + args.toList()
            workingDir = projectDir
            standardOutput = output
            errorOutput = errorOutput
            ignoreExitValue = true
        }

        if (result.exitValue != 0) {
            println "Command failed: ${args.join(' ')}"
            println output.toString()
            println errorOutput.toString()
            return false
        }
        return true
    } catch (Exception e) {
        println "Error executing Docker command: ${e.message}"
        return false
    }
}

// Docker Compose Î™ÖÎ†πÏñ¥ Ïã§Ìñâ
def dockerCompose(String... args) {
    return executeDockerCommand("compose", *args)
}

// Docker Compose Î™ÖÎ†πÏñ¥ Ïã§Ìñâ (ÌäπÏ†ï ÌååÏùº ÏßÄÏ†ï)
def dockerComposeWithFile(String file, String... args) {
    return executeDockerCommand("compose", "-f", file, *args)
}

// Í∞ÑÌé∏Ìïú Docker Tasks
task dockerUp {
    group = 'docker-simple'
    description = 'Start noti service with docker compose up -d'
    doLast {
        if (dockerCompose("up", "-d")) {
            println "‚úÖ Noti service started successfully"
            println "View logs: ./gradlew dockerLogs"
            println "Check status: docker ps"
        } else {
            println "‚ùå Failed to start noti service"
            println "Make sure Docker Desktop is running"
        }
    }
}

task dockerDown {
    group = 'docker-simple'
    description = 'Stop noti service with docker compose down'
    doLast {
        if (dockerCompose("down")) {
            println "‚úÖ Noti service stopped successfully"
        } else {
            println "‚ùå Failed to stop noti service"
        }
    }
}

task dockerRestart {
    group = 'docker-simple'
    description = 'Restart noti service'
    dependsOn dockerDown, dockerUp
}

task dockerStatus {
    group = 'docker-simple'
    description = 'Show Docker container status'
    doLast {
        executeDockerCommand("ps", "--format", "table {{.Names}}\\t{{.Status}}\\t{{.Ports}}")
    }
}

task dockerBuildAndRun {
    group = 'docker-simple'
    description = 'Build JAR file and run noti service'
    dependsOn 'bootJar'
    finalizedBy dockerUp
    doLast {
        println "Building noti service..."
    }
}

task dockerLogs {
    group = 'docker-simple'
    description = 'Show noti service Docker logs'
    doLast {
        executeDockerCommand("logs", "-f", "asyncsite-noti-service")
    }
}

// Noti Service Ï†ÑÏö© Docker Tasks
task dockerBuild {
    group = 'docker-simple'
    description = 'Build Noti Service Docker image'
    dependsOn 'bootJar'
    doLast {
        if (executeDockerCommand("build", "-t", "ghcr.io/asyncsite/noti-service:latest", ".")) {
            println "‚úÖ Noti service Docker image built successfully"
        } else {
            println "‚ùå Failed to build Docker image"
        }
    }
}

// Noti Service Only (Ïù∏ÌîÑÎùºÍ∞Ä Ïù¥ÎØ∏ Ïã§Ìñâ Ï§ëÏùº Îïå)
task dockerUpNotiOnly {
    group = 'docker-simple'
    description = 'Start only noti service when infrastructure is already running'
    doLast {
        if (dockerComposeWithFile("docker-compose.noti-only.yml", "up", "-d")) {
            println "‚úÖ Noti service started successfully (using existing infrastructure)"
            println "View logs: ./gradlew dockerLogsNotiOnly"
            println "Check status: docker ps"
        } else {
            println "‚ùå Failed to start noti service"
            println "Make sure infrastructure services are already running"
        }
    }
}

task dockerDownNotiOnly {
    group = 'docker-simple'
    description = 'Stop only noti service (keeps infrastructure running)'
    doLast {
        if (dockerComposeWithFile("docker-compose.noti-only.yml", "down")) {
            println "‚úÖ Noti service stopped successfully"
        } else {
            println "‚ùå Failed to stop noti service"
        }
    }
}

task dockerRestartNotiOnly {
    group = 'docker-simple'
    description = 'Restart only noti service'
    dependsOn dockerDownNotiOnly, dockerUpNotiOnly
}

// Ensure clean happens before bootJar
tasks.named('bootJar') {
    mustRunAfter 'clean'
}

task dockerRebuildAndRunNotiOnly {
    group = 'docker-simple'
    description = 'Test, completely rebuild and run noti service (removes old container and image)'
    
    dependsOn 'clean', 'test', 'bootJar'
    
    doLast {
        println "‚úÖ All tests passed successfully!"
        
        // Stop and remove container
        if (dockerComposeWithFile("docker-compose.noti-only.yml", "down")) {
            println "‚úÖ Noti service stopped and removed"
        }
        
        // Remove old image
        executeDockerCommand("rmi", "ghcr.io/asyncsite/noti-service:latest", "-f")
        println "‚úÖ Old noti service image removed"
        
        println "üî® Building Docker image..."
        if (executeDockerCommand("build", "-t", "ghcr.io/asyncsite/noti-service:latest", ".")) {
            println "‚úÖ Noti service Docker image built successfully"
            
            println "üöÄ Starting noti service..."
            if (dockerComposeWithFile("docker-compose.noti-only.yml", "up", "-d")) {
                println "‚úÖ Noti service started successfully"
                println "View logs: ./gradlew dockerLogsNotiOnly"
                println "Service endpoints:"
                println "  - Health: http://localhost:8089/actuator/health"
                println "  - Swagger: http://localhost:8089/swagger-ui/index.html"
                println "  - API: http://localhost:8089/api/notifications"
                
                // Docker Ï†ïÎ¶¨ ÏàòÌñâ (ÏïàÏì∞Îäî Î¶¨ÏÜåÏä§ Ï†úÍ±∞)
                def skipCleanup = project.hasProperty("skipDockerCleanup") && project.skipDockerCleanup == "true"
                if (!skipCleanup) {
                    dockerAggressiveCleanup()
                } else {
                    println "‚ÑπÔ∏è Skipping Docker cleanup (skipDockerCleanup=true)"
                }
            } else {
                println "‚ùå Failed to start noti service"
            }
        } else {
            println "‚ùå Failed to build Docker image"
        }
    }
}

task dockerBuildAndRunNotiOnly {
    group = 'docker-simple'
    description = 'Build JAR and run only noti service'
    dependsOn 'bootJar'
    finalizedBy dockerUpNotiOnly
    doLast {
        println "Building noti service..."
    }
}

task dockerLogsNotiOnly {
    group = 'docker-simple'
    description = 'Show noti service Docker logs'
    doLast {
        executeDockerCommand("logs", "-f", "asyncsite-noti-service")
    }
}

task dockerRunStandalone {
    group = 'docker-simple'
    description = 'Run Noti Service as standalone container (ensure infrastructure is running)'
    dependsOn dockerBuild
    doLast {
        // Stop and remove existing container if it exists
        executeDockerCommand("stop", "asyncsite-noti-service")
        executeDockerCommand("rm", "asyncsite-noti-service")
        
        if (executeDockerCommand(
            "run", "-d",
            "--name", "asyncsite-noti-service",
            "--network", "asyncsite-network",
            "-p", "8089:8089",
            "-e", "SPRING_PROFILES_ACTIVE=docker",
            "-e", "EUREKA_CLIENT_SERVICE_URL_DEFAULTZONE=http://asyncsite-eureka:8761/eureka/",
            "-e", "SPRING_DATASOURCE_URL=jdbc:mysql://asyncsite-mysql:3306/notidb?useSSL=false&serverTimezone=UTC&allowPublicKeyRetrieval=true&createDatabaseIfNotExist=true",
            "-e", "SPRING_DATASOURCE_USERNAME=root",
            "-e", "SPRING_DATASOURCE_PASSWORD=asyncsite_root_2024!",
            "ghcr.io/asyncsite/noti-service:latest"
        )) {
            println "‚úÖ Noti service container started successfully"
            println "Access at: http://localhost:8089"
        } else {
            println "‚ùå Failed to start noti service container"
            println "Make sure core-platform infrastructure is running"
        }
    }
}

// Filebeat Commands
task dockerUpWithFilebeat {
    group = 'docker-simple'
    description = 'Start noti service with Filebeat for ELK logging'
    doLast {
        if (dockerComposeWithFile("docker-compose.with-filebeat.yml", "up", "-d")) {
            println "‚úÖ Noti service with Filebeat started successfully"
            println "View logs: ./gradlew dockerLogsWithFilebeat"
            println "Check status: docker ps"
        } else {
            println "‚ùå Failed to start noti service with Filebeat"
            println "Make sure infrastructure services and ELK stack are running"
        }
    }
}

task dockerDownWithFilebeat {
    group = 'docker-simple'
    description = 'Stop noti service with Filebeat'
    doLast {
        if (dockerComposeWithFile("docker-compose.with-filebeat.yml", "down")) {
            println "‚úÖ Noti service with Filebeat stopped successfully"
        } else {
            println "‚ùå Failed to stop noti service with Filebeat"
        }
    }
}

task dockerLogsWithFilebeat {
    group = 'docker-simple'
    description = 'Show noti service and Filebeat logs'
    doLast {
        println "=== Noti Service Logs ==="
        executeDockerCommand("logs", "--tail", "50", "asyncsite-noti-service")
        println "\n=== Filebeat Logs ==="
        executeDockerCommand("logs", "--tail", "50", "asyncsite-filebeat-noti-service")
    }
}

// Help task to show all Docker commands
task dockerHelp {
    group = 'docker-simple'
    description = 'Show all available Docker commands'
    doLast {
        println """
=== Noti Service Docker Commands ===

Full Stack Commands (includes infrastructure):
  ./gradlew dockerUp                  - Start all services with docker-compose
  ./gradlew dockerDown                - Stop all services
  ./gradlew dockerRestart             - Restart all services
  ./gradlew dockerBuildAndRun         - Build JAR and run all services

Noti Service Only Commands (when infrastructure is already running):
  ./gradlew dockerUpNotiOnly          - Start only noti service
  ./gradlew dockerDownNotiOnly        - Stop only noti service
  ./gradlew dockerRestartNotiOnly     - Restart only noti service
  ./gradlew dockerBuildAndRunNotiOnly - Build JAR and run only noti service
  ./gradlew dockerRebuildAndRunNotiOnly - Completely rebuild and run (removes old container/image)
  ./gradlew dockerLogsNotiOnly        - Show noti service logs

Filebeat/ELK Commands:
  ./gradlew dockerUpWithFilebeat      - Start noti service with Filebeat
  ./gradlew dockerDownWithFilebeat    - Stop noti service with Filebeat
  ./gradlew dockerLogsWithFilebeat    - Show noti service and Filebeat logs

Other Commands:
  ./gradlew dockerBuild               - Build Docker image
  ./gradlew dockerStatus              - Show container status
  ./gradlew dockerLogs                - Show logs (follows output)
  ./gradlew runInfraOnly              - Run only infrastructure from core-platform

Note: Use *NotiOnly commands when MySQL and Eureka are already running.
      Use *WithFilebeat commands when ELK stack is running.
"""
    }
}

// Docker Ï†ÑÏ≤¥ Ï†ïÎ¶¨ ÌÉúÏä§ÌÅ¨
task dockerSystemCleanup {
    group = 'docker-maintenance'
    description = 'Aggressive cleanup of ALL unused Docker resources across all services'
    
    doLast {
        println "=" * 60
        println "    DOCKER SYSTEM CLEANUP - ALL UNUSED RESOURCES"
        println "=" * 60
        
        // Ïã§Ìñâ Ï§ëÏù∏ ÏÑúÎπÑÏä§ ÌôïÏù∏
        println "\nüì¶ Current running containers:"
        executeDockerCommand("ps", "--format", "table {{.Names}}\t{{.Image}}\t{{.Status}}")
        
        println "\n‚ö†Ô∏è  WARNING: This will remove:"
        println "   - ALL stopped containers"
        println "   - ALL dangling images"
        println "   - ALL unused AsyncSite images"
        println "   - Build cache older than 24h"
        println "   - Unused networks"
        println "\nStarting cleanup in 3 seconds..."
        Thread.sleep(3000)
        
        dockerAggressiveCleanup()
    }
}

// Infrastructure only (for local development)
task runInfraOnly {
    group = 'docker-simple'
    description = 'Run only infrastructure (MySQL, Eureka) from core-platform for local development'
    doLast {
        def corePlatformDir = file("../core-platform")
        def dockerPath = findDockerExecutable()
        
        if (!corePlatformDir.exists()) {
            println "‚ùå Core platform directory not found at ../core-platform"
            return
        }
        
        if (!dockerPath) {
            println "‚ùå Docker not found. Please make sure Docker Desktop is installed and running."
            return
        }
        
        exec {
            commandLine dockerPath, "compose", "up", "-d", "mysql", "eureka-server"
            workingDir = corePlatformDir
        }
        println "‚úÖ Infrastructure services started from core-platform"
        println "MySQL: localhost:3306"
        println "Eureka: http://localhost:8761"
    }
}